from TopLevelError import TopLevelError
from .download import download
from Config import INSTALL_INI, INSTALLED_F, KEY_EXCLUDE, KEY_INCLUDE, KEY_REQUIRE
from datafile.InstalledLog import InstalledLog
from datafile.Requirements import Requirements
from project.ConfigFile import ConfigFile
from filesys.exclude import exclude
from filesys.extract import extract

from os import path, listdir, rename
from shutil import rmtree
import sys

PKG_ALREADY_EXISTS = '''
Package folder %s already exists but was not previously installed.
This may be a conflict in folder name and the package is not installed.
'''

EXE_ALREADY_EXISTS = '''
Attempted to extract binary %s,
but it already exists at root directory.
'''

REMOVE = "Removed %s"
REQUIRES = "Package %s depends on:"
NO_ACTION = "%s is already installed."

class InvalidPackage(TopLevelError):
	'''The specified package is not valid because it does not have:
	1) lowercase package directory AND
	2) git-install.ini'''

def install(pkgnames):
	with InstalledLog(INSTALLED_F) as log:
		for pkg in pkgnames:
			installOne(pkg, log)

def simplyInstall(pkgname, pack, package, log):
	config = getConfig(package)

	log.add(pkgname, list(extractBinaries(package)))
	extract(pack, package)
	exclude(pack, config.get(KEY_INCLUDE), config.get(KEY_EXCLUDE))
	
	return config.get(KEY_REQUIRE)

# === PROTECTED ===

def installOne(pkgname, log):
	r = Requirements.parse(pkgname)
	if isNotInstalled(pkgname, log, r):
		try:
			installPkg(pkgname, log, r)
		except TopLevelError as e:
			cleanup(r.package)
			raise e

def isNotInstalled(pkgname, log, r):
	if path.isdir(r.folder) or path.isdir(r.package):
		if not log.has(pkgname):
			sys.stderr.write(PKG_ALREADY_EXISTS % pkgname)
		else:
			print(NO_ACTION % pkgname)
		return False
	else:
		return True

def installPkg(pkgname, log, r):
	download(pkgname)
	requires = simplyInstall(pkgname, r.folder, r.package, log)
	notifyRequires(pkgname, requires)
	for reqPkg in requires:
		installOne(str(reqPkg), log)

def extractBinaries(pkg):
	binf = path.join(pkg, "bin")
	if path.isdir(binf):
		for f in listdir(binf):
			fname = path.join(binf, f)
			if not path.exists(f):
				rename(fname, f)
				yield f
			else:
				sys.stderr.write(EXE_ALREADY_EXISTS % fname)

def notifyRequires(pkgname, requires):
	if requires:
		header = REQUIRES % pkgname
		out = "\n\t+ ".join([header] + list(map(str, requires)))
		print(out)

def cleanup(package):
	if path.isdir(package):
		rmtree(package)
		print(REMOVE % package)

def getConfig(pkg):
	configf = path.join(pkg, INSTALL_INI)
	if not path.isfile(configf):
		raise InvalidPackage
	return ConfigFile(configf)
